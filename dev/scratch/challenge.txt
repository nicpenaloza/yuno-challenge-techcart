The Dynamic Routing Failure: Build TechCart's Failover Intelligence API
The Scenario
TechCart, a fast-growing electronics marketplace operating across Brazil, Mexico, and Colombia, processes approximately 15,000 transactions daily through Yuno's payment orchestration platform. Three weeks ago, they launched a major promotional campaign that doubled their traffic overnight.

Yesterday, disaster struck. During peak hours (7-9 PM local time), their primary payment processor in Brazil—which handles 60% of their PIX transactions—experienced a 4-hour outage. TechCart's current payment routing logic is static: it always tries the primary processor first, then falls back to a secondary processor only after the primary returns a timeout or error.

The result? Over 8,000 customers abandoned their carts during the outage window. Even worse, TechCart's operations team didn't realize the primary processor was down for nearly 90 minutes—they only discovered it when customer complaints flooded their support channels. By the time they manually switched traffic to the backup processor, the damage was done: an estimated $420,000 in lost revenue.

TechCart's CTO has escalated to Yuno with an urgent request: they need an intelligent routing engine that can automatically detect when a processor is underperforming or unavailable, make real-time routing decisions based on recent success rates, and provide visibility into processor health across all their markets.

Your mission: Build a backend service and API that implements smart payment routing logic, monitors processor health in real-time, and helps TechCart avoid future outages.

Domain Background
Before diving in, here are the key payment concepts you'll need to understand:

Payment Orchestration
Companies like Yuno act as a payment orchestration layer between merchants (like TechCart) and multiple payment processors (also called PSPs - Payment Service Providers). Instead of integrating with each processor individually, merchants integrate once with Yuno, which then routes transactions to the appropriate processor based on various factors.

Payment Processors / PSPs
These are companies that actually process payment transactions (e.g., connecting to card networks, handling bank transfers, etc.). A merchant typically integrates with 2-5 processors to ensure redundancy and coverage across different payment methods. Each processor has:

Availability: Is it responding to requests?
Authorization rate: What percentage of transaction attempts does it successfully approve?
Latency: How fast does it respond?
Payment Methods
PIX: Brazil's instant payment system. Transfers happen in seconds and are very popular for e-commerce.
Credit/Debit Cards: Traditional card payments (Visa, Mastercard, etc.)
OXXO: A Mexican cash payment method where customers receive a voucher code and pay at physical OXXO convenience stores.
PSE: Colombia's online bank transfer system.
Authorization
When a customer attempts to pay, the payment processor tries to authorize the transaction (verify funds, check for fraud, etc.). The processor returns one of several outcomes:

Approved: Transaction successful
Declined: Transaction rejected (insufficient funds, fraud detection, etc.)
Error/Timeout: Technical failure (processor is down, network issue, etc.)
Authorization Rate
The percentage of transaction attempts that result in approval. For example, if 100 customers try to pay and 73 are approved, the authorization rate is 73%. A healthy processor typically maintains 65-85% authorization rates. A sudden drop (e.g., to 20% or 0%) often indicates an outage or technical issue.

Routing
The logic that determines which processor should handle a given transaction. Static routing always tries processors in the same order. Smart/dynamic routing makes decisions based on real-time data (processor health, authorization rates, cost, etc.).

Functional Requirements
Build a backend service that solves TechCart's problem. Your solution should:

1. Real-Time Processor Health Monitoring
The system must track the health and performance of multiple payment processors in real-time:

Accept incoming transaction result data (approved, declined, error, timeout) with processor ID, timestamp, payment method, country, and transaction amount
Calculate rolling authorization rates for each processor over recent time windows (e.g., last 50 transactions, last 10 minutes—you decide the window that makes sense)
Detect when a processor's performance degrades below acceptable thresholds
Provide a clear "health status" for each processor (e.g., HEALTHY, DEGRADED, DOWN) based on recent performance
What "done" looks like: A reviewer can send a stream of transaction results to your service and query the current health status of each processor. If they send 50 consecutive failures for a processor, your service should mark it as DOWN or DEGRADED.

2. Intelligent Routing Decisions
The system must recommend which processor should handle the next transaction:

When asked "which processor should handle this transaction?" (given payment method, country, and amount), return a ranked recommendation based on current processor health
Prioritize processors with higher recent authorization rates and healthy status
Ensure that processors marked as DOWN or severely degraded are not recommended (or ranked last)
Handle the case where multiple processors support the same payment method in the same country
What "done" looks like: A reviewer can query your API with transaction details and receive a clear routing recommendation. If they previously sent data showing Processor A is down and Processor B is healthy, your system should recommend Processor B.

3. Operational Visibility API
Provide endpoints that give TechCart's operations team visibility into what's happening:

Query current health status and recent authorization rates for all processors
View historical performance trends (e.g., authorization rate over the last hour)
Identify which processor would be selected for a given transaction scenario
Surface alerts or warnings when processors transition to unhealthy states
What "done" looks like: A reviewer can use your API to answer questions like "Which processors are currently healthy?", "What's Processor A's authorization rate over the last 100 transactions?", and "When did Processor B's status change to DOWN?"

Stretch Goals (Partial completion expected and welcomed!)
Circuit breaker pattern: Automatically "open" a circuit for a failing processor (stop sending traffic) and periodically test if it has recovered
Multi-dimensional routing: Consider additional factors beyond health (e.g., processor cost/fees, latency, time-of-day patterns)
Anomaly detection: Alert when a processor's authorization rate drops suddenly (e.g., 20% drop in 5 minutes) even if it's still above the absolute "DOWN" threshold
Geographic intelligence: Track processor performance separately by country/region, since a processor might be down in Brazil but healthy in Mexico
Test Data
Your solution needs realistic data to develop against and demonstrate in action. Generate or create a test dataset with the following characteristics:

At least 4-5 mock payment processors (give them IDs or names like "ProcessorA", "GlobalPay_BR", etc.)
Each processor should support specific combinations of payment methods and countries (e.g., Processor A handles PIX in Brazil, Processor B handles cards in Mexico and Colombia, Processor C handles both PIX and cards in Brazil)
At least 1,000 transaction result records with:
Processor identifier
Timestamp (spread over several hours, with some concentration during "peak hours")
Transaction outcome (approved, declined, error, timeout)
Payment method (PIX, card, OXXO, PSE)
Country (BR, MX, CO)
Transaction amount (in local currency)
Include realistic patterns:
Most processors should have 65-80% authorization rates under normal conditions
Simulate an outage: One processor should have a 2-3 hour window where it returns mostly errors/timeouts (mimicking TechCart's actual incident)
Simulate degradation: Another processor should show gradually declining authorization rates
Include some normal declined transactions (these are expected—insufficient funds, etc.)
You can generate this with code, AI tools, or scripts. The key is having enough data to demonstrate your health monitoring and routing logic working correctly.

Acceptance Criteria
Your solution is complete when:

✅ A reviewer can send transaction results to your service via API
✅ Your service accurately calculates and exposes processor health status based on recent performance
✅ A reviewer can query for routing recommendations and receive sensible answers based on current processor health
✅ The service correctly identifies and deprioritizes failing processors in routing decisions
✅ The system provides visibility into authorization rates and processor status through API endpoints
✅ You include a README with:

Setup instructions
API documentation (what endpoints exist, what they do, example requests/responses)
Explanation of your health calculation logic and routing algorithm
How to load/generate test data
How to demonstrate the "outage scenario" where one processor fails and routing shifts to healthy alternatives
Technical Constraints
Your solution must expose a REST or GraphQL API (your choice)
Choose any backend language, framework, and data storage approach you prefer
You may use in-memory storage, a database, or any other persistence mechanism
Focus on correctness and clarity over production-grade scalability
What We're Looking For
We want to see:

Clean, understandable code that another engineer could maintain
Thoughtful algorithm design for health calculation and routing logic
Good API design that's intuitive and well-documented
Effective use of AI tools to move quickly while maintaining quality
A working demo that clearly shows the system detecting failures and making smart routing decisions
This is a 2-hour challenge. We expect a focused, working prototype—not a production-ready system. Prioritize the core requirements and document what you'd improve with more time.

